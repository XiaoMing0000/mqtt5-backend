# MQTT5 服务性能基准测试报告

## 📋 目录

- [测试环境](#测试环境)
- [测试配置](#测试配置)
- [连接基准测试](#连接基准测试)
- [订阅基准测试](#订阅基准测试)
- [消息推送基准测试](#消息推送基准测试)
- [性能分析与对比](#性能分析与对比)
- [适用场景评估](#适用场景评估)
- [优化建议](#优化建议)
- [免责声明](#免责声明)

## 🖥️ 测试环境

### 宿主机配置

- **内存**: DDR4 32 GiB (双通道 2400 MT/s × 2)
- **CPU**: Intel Core i5-10400F @ 2.90GHz (12 核心)
- **存储**: Samsung SSD 970 EVO Plus 500GB
- **网络**: 1 Gbps
- **操作系统**: AlmaLinux 9.5 (Teal Serval)

### 容器配置

- **容器管理**: Podman
- **内存限制**: 512MB
- **CPU 限制**: 1 核心
- **基础镜像**: Node.js 22.14-alpine

### 服务配置

- **消息管理**: MemoryManager (内存模式)
- **技术栈**: Node.js
- **部署模式**: 单实例
- **协议版本**: MQTT 5.0

## ⚙️ 测试配置

### 服务端配置

```typescript
import { MqttServer, MemoryManager, MqttServerWebSocket } from '@elfdream/mqtt5-backend';

const clientManager = new MemoryManager();
const mqttServer = new MqttServer(clientManager);
const wsMqttServer = new MqttServerWebSocket(clientManager);

mqttServer.maxConnections = 1000000;

setInterval(() => {
	console.log(new Date().toISOString(), 'client count:', clientManager.clientIdentifierManager.size);
}, 5000);

mqttServer.listen(1883, () => {
	console.log('MQTT server started on port 1883.');
});

wsMqttServer.listen(8083, () => {
	console.log('WebSocket server started on port 8083.');
});
```

### 测试工具

- **工具**: emqtt-bench
- **版本**: latest
- **运行环境**: Podman 容器

## 🔗 连接基准测试

### 测试命令

```bash
podman run -it emqtt-bench:latest \
    conn \
    -h "localhost" \
    -p 1883 \
    -V 5 \
    -c 28000 \
    -i 1
```

### 测试结果

| 指标             | 数值                       | 说明                           |
| ---------------- | -------------------------- | ------------------------------ |
| **连接建立速率** | 960 cps                    | 每秒最大连接数                 |
| **最大连接数**   | 28,232                     | 受服务器资源限制               |
| **CPU 占用**     | 12% (建立) / 0.14% (保持)  | 建立连接时较高，保持连接时极低 |
| **内存占用**     | 94.91MB / 536.9MB (17.68%) | 内存使用效率高                 |
| **磁盘 I/O**     | 0B                         | 纯内存操作                     |
| **网络流量**     | 9.278MB / 6.441MB          | 入站/出站流量                  |

### 性能分析

- ✅ **高连接承载能力**: 单实例 Node.js 能承载 2.8 万连接，表现优秀
- ✅ **低 CPU 占用**: 保持连接时 CPU 使用率仅 0.14%，说明事件循环高效
- ✅ **内存效率高**: MemoryManager 内存管理高效，占用率低
- ⚠️ **资源限制**: 极限主要受操作系统 socket fd 和 ephemeral port 限制

## 📡 订阅基准测试

### 测试命令

```bash
podman run -it emqtt-bench:latest \
    sub \
    -h "localhost" \
    -p 1883 \
    -V 5 \
    -c 28232 \
    -i 1 \
    -t bench/%i
```

### 测试结果

| 指标             | 数值                       | 说明                 |
| ---------------- | -------------------------- | -------------------- |
| **订阅处理速率** | 923 cps                    | 每秒完成订阅数       |
| **连接建立速率** | 903 cps                    | 每秒建立连接数       |
| **最大连接数**   | 28,232                     | 与连接测试一致       |
| **CPU 占用**     | 12% (建立) / 0.14% (保持)  | 与连接测试相同       |
| **内存占用**     | 108.4MB / 536.9MB (20.18%) | 订阅管理增加少量内存 |
| **磁盘 I/O**     | 0B                         | 纯内存操作           |
| **网络流量**     | 13.58MB / 8.528MB          | 入站/出站流量        |

### 性能分析

- ✅ **高效订阅处理**: 每秒 900+ 订阅处理能力，Node.js 内存管理下表现优秀
- ✅ **低 CPU 占用**: 订阅操作主要是内存操作，无阻塞
- ✅ **稳定内存使用**: 数据结构设计合理，内存占用仍然较低
- ✅ **可靠性能**: 可以轻松支撑 2~3 万连接同时订阅操作

## 📤 消息推送基准测试

### 测试命令

```bash
podman run -it emqtt-bench:latest \
    pub \
    -h "localhost" \
    -p 1883 \
    -V 5 \
    -c 1000 \
    -I 1 \
    -t bench/%i \
    -s 512 \
    -q 2
```

### 测试结果

| 指标             | 数值                      | 说明               |
| ---------------- | ------------------------- | ------------------ |
| **消息推送速率** | 12,124 qps                | 每秒消息推送数量   |
| **最大连接数**   | 1,000                     | 消息推送测试连接数 |
| **CPU 占用**     | 79.06%                    | 接近单核 CPU 上限  |
| **内存占用**     | 21.97MB / 536.9MB (4.09%) | 内存使用极低       |
| **磁盘 I/O**     | 0B                        | 纯内存处理         |
| **网络流量**     | 288.7MB / 83.81MB         | 高网络吞吐量       |

### 性能分析

- ✅ **高消息吞吐量**: 12k QPS 对单实例 Node.js 服务来说表现优秀
- ⚠️ **CPU 瓶颈**: 接近 80% CPU 占用，说明消息序列化、QoS2 保证和 topic 匹配是性能瓶颈
- ✅ **内存效率**: 消息没有持久化到磁盘，一切在内存处理，效率极高
- ⚠️ **网络带宽**: 288 MB/s 出站流量，带宽可能成为进一步扩展的瓶颈
- 🔴 **扩展限制**: 增加连接数或消息大小会导致更高 CPU 负载，需要多实例部署

## 📊 性能分析与对比

### 性能量级评估

基于测试结果，该 MQTT5 服务的性能表现：

- **连接处理能力**: 960 cps (每秒连接数)
- **订阅处理能力**: 923 cps (每秒订阅数)
- **消息推送能力**: 12,124 qps (每秒消息数)
- **最大连接数**: 28,232 个并发连接
- **资源效率**: CPU 0.14% (空闲) / 79% (推送)，内存使用率 < 21%

### 与主流 MQTT Broker 对比

| MQTT Broker         | 测试环境            | 连接/订阅吞吐量 | 技术栈  | 对比评价          |
| ------------------- | ------------------- | --------------- | ------- | ----------------- |
| **Mosquitto**       | 单核 CPU、1GB RAM   | 300–800/s       | C       | 🟢 **略胜一筹**   |
| **EMQX**            | 4 核 CPU、4GB RAM   | 2,000–10,000/s  | Erlang  | 🟡 **稍逊一筹**   |
| **HiveMQ**          | 4 核 CPU、4GB RAM   | 5,000–15,000/s  | Java    | 🟡 **有差距**     |
| **Aedes (Node.js)** | 2–4 核              | 500–1,500/s     | Node.js | 🟢 **相当或略好** |
| **VerneMQ**         | 4 核                | 2,000–8,000/s   | Erlang  | 🟡 **稍逊一筹**   |
| **本服务**          | 1 核 CPU、512MB RAM | ~923/s          | Node.js | 🟢 **中上水平**   |

### 性能指标对比

| 指标             | 本服务结果   | 行业水平             | 评价          |
| ---------------- | ------------ | -------------------- | ------------- |
| **连接建立速率** | 960 cps      | Mosquitto 级别       | ✅ 性能中上   |
| **订阅处理速率** | 923 cps      | Mosquitto/Aedes 范围 | ✅ 正常表现   |
| **消息推送速率** | 12,124 qps   | 单实例优秀           | ✅ 表现突出   |
| **CPU 占用**     | 0.14% (空闲) | 极低                 | 💪 性能稳定   |
| **内存使用**     | < 21%        | 较低                 | ✅ 优秀稳定   |
| **最大连接数**   | 28,232       | 单实例较高           | ✅ 承载能力强 |

## 🎯 适用场景评估

| 应用场景                     | 推荐性能要求 | 本服务表现  | 适用性评价      |
| ---------------------------- | ------------ | ----------- | --------------- |
| **家庭自动化 / IoT 网关**    | ≥ 100/s      | 🟢 远超需求 | ✅ **完全适用** |
| **工业 IoT 网关 / 边缘节点** | ≥ 500/s      | 🟢 性能充足 | ✅ **完全适用** |
| **企业级 MQTT Broker**       | ≥ 2,000/s    | 🟡 稍显不足 | ⚠️ **需要优化** |
| **云端百万连接集群**         | ≥ 10,000/s   | 🔴 不够     | ❌ **不适用**   |

### 适用性总结

**✅ 完全适用场景:**

- 中小型 IoT 项目
- 边缘计算网关
- 智能家居系统
- 原型开发和测试环境

**⚠️ 需要优化场景:**

- 企业级应用
- 大规模部署
- 高并发消息处理

**❌ 不适用场景:**

- 超大规模集群
- 百万级连接
- 极高并发场景

## 🚀 优化建议

### 短期优化 (立即可实施)

1. **多进程部署**

   - 使用 PM2 或 Node.js cluster 模块
   - 预期提升: 900/s → 3,000-4,000/s
   - 实施难度: ⭐⭐

2. **关闭非必要日志**

   - 减少文件系统 I/O 延迟
   - 预期提升: 5-10% 性能
   - 实施难度: ⭐

3. **优化 Keep-Alive 设置**
   - 使用长连接避免重复连接/订阅
   - 预期提升: 实际吞吐量显著提高
   - 实施难度: ⭐

### 中期优化 (需要开发)

4. **订阅匹配算法优化**

   - 使用 Trie 树或 Hash Table 替代线性查找
   - 预期提升: 订阅性能 20-30%
   - 实施难度: ⭐⭐⭐

5. **消息批处理**
   - 实现消息批量处理机制
   - 预期提升: 消息吞吐量 15-25%
   - 实施难度: ⭐⭐⭐

### 长期优化 (架构升级)

6. **Redis 集群支持**

   - 实现分布式消息存储
   - 预期提升: 支持水平扩展
   - 实施难度: ⭐⭐⭐⭐

7. **消息持久化**

   - 添加消息持久化机制
   - 预期提升: 生产环境可靠性
   - 实施难度: ⭐⭐⭐⭐

8. **负载均衡**
   - 实现多实例负载均衡
   - 预期提升: 支持更大规模部署
   - 实施难度: ⭐⭐⭐⭐⭐

## 📝 总结

### 整体评价

该 MQTT5 服务在**单实例 Node.js 实现**中属于**中上水平**：

- **连接处理能力**: 960 cps，略优于 Mosquitto
- **订阅处理能力**: 923 cps，与 Aedes 相当
- **消息推送能力**: 12,124 qps，单实例表现优秀
- **资源效率**: CPU 和内存使用率都很低，效率极高

### 核心优势

✅ **高连接承载**: 单实例支持 2.8 万并发连接  
✅ **资源高效**: 内存占用低，CPU 使用合理  
✅ **协议完整**: 支持完整 MQTT5 特性  
✅ **代码质量**: 模块化设计，易于维护

### 主要限制

⚠️ **单线程瓶颈**: Node.js 事件循环限制  
⚠️ **无持久化**: 纯内存存储，重启数据丢失  
⚠️ **无集群**: 单实例架构，无法水平扩展

### 适用建议

- **推荐场景**: 中小型 IoT 项目、边缘计算、智能家居
- **需要优化**: 企业级应用、大规模部署
- **不推荐**: 超大规模集群、百万级连接

---

## ⚠️ 免责声明

本测试报告中提供的性能数据，包括最大连接数、订阅速率、消息推送速率，以及 CPU、内存和网络使用情况，均基于特定测试环境、特定硬件配置、软件版本和测试工具获得。

### 测试环境限制

- **硬件环境**: Intel i5-10400F CPU、32GB DDR4 内存、Samsung SSD
- **软件环境**: AlmaLinux 9.5、Node.js 22.14、Podman 容器
- **服务配置**: 单实例、内存模式、512MB 容器内存限制

### 重要说明

1. **环境差异**: 不同硬件、操作系统、网络条件可能导致结果显著不同
2. **性能波动**: 性能指标可能随负载、消息大小、QoS 级别等因素变化
3. **不构成保证**: 本报告不保证任何实际部署环境中能够达到相同性能指标
4. **风险自负**: 因使用本数据导致的任何损失，测试方不承担任何责任

**建议**: 用户应根据自身生产环境和业务需求进行独立测试与评估。
